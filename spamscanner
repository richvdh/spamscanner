#!/usr/bin/env python
#
# Feeds false positive and negative spam through spamassassin's learner.
#
# For each folder for each user, first looks for a 'spam' subfolder, and
# if such exists, looks for mail which has appeared since the last run and
# which does not have the spam header set. Learns any such mail as spam, then
# flags it as deleted.
#
# Then looks through the main folder for new mail which does have the spam
# header set. Learns such mail as non-spam.
#
# If a permission error is returned when trying to select a folder, attempts
# to grant itself access rights on the folder and tries again. This will work
# fine provided the spamscanner user is configured as an admin user
# (/etc/imapd.conf/imap_admins)

from __future__ import print_function

import argparse
import imaplib
import pickle
import re
import socket
import sys
import traceback


class ImapRequestError(Exception):
    def __init__(self, rtype, data):
        super(ImapRequestError, self).__init__(
            "IMAP error: %r" % ((rtype, data),))

        # one of OK or NO, normally
        self.rtype = rtype

        # list of results from the command; each entry is either a
        # string, or a tuple. If a tuple, then the first part is the
        # header of the response, and the second part contains the data
        # (ie: 'literal' value).
        self.data = data


def check_response(response):
    """ Check the response from an imap operation

    Expects 'response' to be a (type, [data...]) result from an IMAP
    operation.

    If 'type' is not OK, throws an ImapRequestError with the result.

    Otherwise, returns the [data...] list.
    """
    if response[0] == 'OK':
        return response[1]
    raise ImapRequestError(*response)


class Scanner(object):
    def __init__(self, imap, state):
        self.imap = imap

        # state is a map from mailbox name to the starting point for the next
        # run (ie, one more than the last message we saw.)
        self.state = state

        # debug level
        self.debug = 0

        self.spam_header = ''
        self.spamscanner_user = ''

    def dbg(self, level, msg):
        if level > self.debug:
            return
        print(msg, file=sys.stderr)

    def select_mbox(self, mbox):
        """ Select the given mailbox
        """
        try:
            check_response(self.imap.select(mbox, readonly=True))
            return
        except ImapRequestError as e:
            pass

        # permission error; try setting the ACL and try again
        self.dbg(0, "Setting acl on %s..." % mbox)
        check_response(self.imap.setacl(mbox, self.spamscanner_user, '+lr'))
        check_response(self.imap.select(mbox, readonly=True))

    def process_mbox(self, mbox, user, isspam):
        self.dbg(
            1, 'processing %s folder %s for %s' % (
                'spam' if isspam else 'ham',
                mbox, user,
            )
        )

        self.select_mbox(mbox)
        uidstart = int(self.state.get(mbox, 0))

        # decide where we're going up to today
        uidnext_resp = self.imap.response('UIDNEXT')
        if uidnext_resp is None:
            raise Exception('no UIDNEXT in response from SELECT')
        uidnext = int(uidnext_resp[1][0])
        self.dbg(2, "range: [%i,%i)" % (uidstart, uidnext))

        if uidnext == uidstart:
            return

        # search for mail which has appeared since the last pass and whose
        # spam header does not match its current status (indicating that the
        # user has moved it).
        (v,) = check_response(self.imap.uid(
            "search", None,
            'UID', "%i:%i" % (uidstart, uidnext-1),
            'UNDELETED',
            'NOT' if isspam else None,
            'HEADER', self.spam_header, 'YES'
        ))

        if v == '':
            return

        for uid in v.split(' '):
            self.fetch_and_report(uid, user, isspam)

        self.state[mbox] = uidnext

    def fetch_and_report(self, uid, user, isspam):
        """ fetch a message from the current mailbox and report it as ham/spam
        """
        self.dbg(2, "Processing %i" % int(uid))

        msgs = check_response(self.imap.uid('fetch', uid, '(RFC822)'))
        msg = msgs[0][1]
        self.do_report('spam' if isspam else 'ham', user, msg)

    def do_report(self, msgclass, user, msg):
        """ send a message to spamd for learning
        """

        # strip CRs to work around
        # https://bz.apache.org/SpamAssassin/show_bug.cgi?id=5185#c30
        msg = msg.replace('\r', '')

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(('127.0.0.1', 783))
        hdr = (
            "TELL SPAMC/1.4\r\n"
            "Message-class: %s\r\n"
            "Set: local\r\n"
            "User: %s\r\n"
            "Content-length: %i\r\n"
            "\r\n"
            % (msgclass, user, len(msg)))

        sock.sendall(hdr)
        sock.sendall(msg)

        while True:
            data = sock.recv(1024)
            if data == '':
                break
            self.dbg(2, "<<< %s" % data)
        sock.close()


def unquote(f):
    """ strip quotes from a name
    """
    if f[0] != '"' or f[-1] != '"':
        return f
    return f[1:-1]


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('-d', '--debug', action='count')
    parser.add_argument('-H', '--host', required=True)
    parser.add_argument('-P', '--port', type=int, default=143)
    parser.add_argument('-u', '--user', default='spamscanner')
    parser.add_argument('-p', '--pass', dest='password', required=True)
    parser.add_argument('--spam_header', default='X-SW1V-Spam-Flag')
    parser.add_argument(
        '--statefile', default='/var/lib/spamscanner/spamscanner.pickle',
    )
    parser.add_argument(
        '--init', action='store_true',
        help='initialise new state file.',
    )
    parser.add_argument(
        '--import-bdb-state', metavar='FILE',
        help='initialise new state from old bdb state file. Requires python 2.'
    )
    args = parser.parse_args()

    if args.import_bdb_state:
        import dbhash
        state = dict(dbhash.open(args.import_bdb_state))
    elif args.init:
        state = {}
    else:
        with open(args.statefile) as f:
            state = pickle.load(f)

    imap = imaplib.IMAP4(args.host, args.port)
    imap.debug = args.debug
    imap.login(args.user, args.password)

    scanner = Scanner(imap, state)
    scanner.debug = args.debug
    scanner.spam_header = args.spam_header
    scanner.spamscanner_user = args.user

    list_response_pattern = re.compile(
        r'\((.*)\) "(.*)" (.*)',
    )
    (r, data) = imap.list()
    for l in data:
        (flags, delim, folder) = list_response_pattern.match(l).groups()

        parts = unquote(folder).split(delim)

        # skip non-user folders
        if parts[0] != 'user':
            scanner.dbg(1, 'skipping folder %s' % folder)
            continue
        user = parts[1]
        isspam = parts[-1] == 'spam'
        try:
            scanner.process_mbox(folder, user, isspam)
        except Exception as e:
            print(
                'Error processing %s:' % (folder, ),
                file=sys.stderr,
            )
            traceback.print_exc(e)
            break

    with open(args.statefile, "w") as f:
        pickle.dump(state, f)
